// let cluster = require('cluster')
// let clusterNum = 0
// if (cluster.isMaster) {
//   let numCPUs = require('os').cpus()
//   numCPUs.map(() => { cluster.fork() })
//   cluster.on('listening', (worker, address) => {
//     clusterNum++
//     if (clusterNum === numCPUs.length) { console.log('项目启动成功！') }
//   })
//   cluster.on('exit', (worker, code, signal) => {
//     setTimeout(function () { cluster.fork() }, 2000)
//   })
// } else if (cluster.isWorker) {
const fs = require('fs')
const path = require('path')
const LRU = require('lru-cache')
const express = require('express')
const cookieParser = require('cookie-parser')
const favicon = require('serve-favicon')
const compression = require('compression')
const microcache = require('route-cache')
const bodyParser = require('body-parser')
const resolve = file => path.resolve(__dirname, file)
const {createBundleRenderer} = require('vue-server-renderer')
const serialize = require('serialize-javascript')
const isProd = process.env.NODE_ENV === 'production'
const useMicroCache = process.env.MICRO_CACHE !== 'false'
const serverInfo =
    `express/${require('express/package.json').version} ` +
    `vue-server-renderer/${require('vue-server-renderer/package.json').version}`
let portconfig = require(process.env.CONFIG_PATH)
process.env.CONFIG_CONFIG = JSON.stringify(portconfig)
// get router config
let routerPaths = {}
let routerPathsObj = {}
// 方法将返回一个包含“指定目录下所有文件名称”的数组对象。
fs.readdirSync('./src/router').map(file => {
  if (file === 'index-server.js' || file === 'index-client.js' || file === '.svn') {
    return false
  }
  let router = require(`./src/router/${file}`)
  if (router) {
    let model = file.split('.js')[0]
    routerPaths[model] = router
    for (let route in router) {
      routerPathsObj[router[route].path] = model
    }
  }
})
const app = express()

function createRenderer (bundle, options) {
  // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
  return createBundleRenderer(bundle, Object.assign(options, {
    // for component caching
    cache: LRU({
      max: 1000,
      maxAge: 1000 * 60 * 15
    }),
    // this is only needed when vue-server-renderer is npm-linked
    basedir: resolve('./dist'),
    // recommended for performance
    runInNewContext: false
  }))
}

let renderer
let readyPromise
const templatePath = resolve('./src/index.template.html')
const templateErrorHtml = fs.readFileSync(resolve('./src/500.template.html'), 'utf-8')

if (isProd) {
  // In production: create server renderer using template and built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  const template = fs.readFileSync(templatePath, 'utf-8')
  const bundle = require('./dist/vue-ssr-server-bundle.json')
  // The client manifests are optional, but it allows the renderer
  // to automatically infer preload/prefetch links and directly add <script>
  // tags for any async chunks used during render, avoiding waterfall requests.
  const clientManifest = require('./dist/vue-ssr-client-manifest.json')
  clientManifest.publicPath = portconfig.staticURL + clientManifest.publicPath
  renderer = createRenderer(bundle, {
    template,
    clientManifest
  })
} else {
  // In development: setup the dev server with watch and hot-reload,
  // and create a new renderer on bundle / index template update.
  readyPromise = require('./build/setup-dev-server')(
      app,
      templatePath,
      (bundle, options) => {
        renderer = createRenderer(bundle, options)
      }
  )
}

const serve = (path, cache) => express.static(resolve(path), {
  maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0
})
app.use(bodyParser.urlencoded({
  extended: false
}))
app.use(bodyParser.json())
app.use(cookieParser())
app.use(compression({threshold: 0}))
app.use(favicon('./public/logo-48.ico'))
app.use('/dist', serve('./dist', true))
app.use('/public', serve('./public', true))
app.use('/manifest.json', serve('./manifest.json', true))
app.use('/service-worker.js', serve('./dist/service-worker.js'))

// since this app has no user-specific content, every page is micro-cacheable.
// if your app involves user-specific content, you need to implement custom
// logic to determine whether a request is cacheable based on its url and
// headers.
// 1-second microcache.
// https://www.nginx.com/blog/benefits-of-microcaching-nginx/
app.use(microcache.cacheSeconds(1, req => useMicroCache && req.originalUrl))
const setConfigCookie = {httpOnly: true, path: '/'}
let {logErr, logInfo} = require('./log4')

function render (req, res) {
  let reqTime = new Date()
  // if (!renderer) {
  //   return res.end('waiting for compilation... refresh in a mwoment.')
  // }
  logInfo('PAGE_IN', req.url, null, req.body, req.cookies)
  res.setHeader('Content-Type', 'text/html')
  res.setHeader('Server', serverInfo)
  const handleError = err => {
    if (err.url) {
      logInfo('PAGE_SEND', err.url, reqTime, req.body, `redirect err url : ${err.url}`)
      res.redirect(err.url)
    } else {
      let message = ''
      if (typeof err === 'object') {
        if (err.head && err.head.returnMsg) {
          message = err.head.returnMsg
        } else {
          message = JSON.stringify(err)
        }
      } else if (typeof err === 'string') {
        message = err
      }
      let errorHtml = templateErrorHtml.replace(/<content[^]*>[^>]*<\/content>/gi, `<div id="errcontent" style="text-align:center"><h1>500 | 网络异常，请刷新重试！</h1><div style="display:none;">Internal Server Error${message}</div></div>`).replace('{{title}}', '500').replace('{{keywords}}', '500').replace('{{description}}', '500')
      // logErr('PAGE_SEND', '', reqTime, req.body, errorHtml)
      res.status(500).send(errorHtml)
      // Render Error Page or Redirect
      // res.status(500).send(`500 | Internal Server Error${req.url}:${err.message}`)
      // res.redirect('/error/500')
    }
  }
  const context = {
    title: 'newroad', // default title
    url: req.url,
    cookie: req.cookies,
    routerPaths: routerPaths,
    routerPathsObj: routerPathsObj,
    useragent: req.headers['user-agent'],
    state: {}
  }
  // process.__COOKIE__ = req.cookie
  // const indexHTML = {
  //   head: '',
  //   tail: ''
  // }
  // const renderStream = renderer.renderToStream(context)
  // // 当块第一次被渲染时
  // renderStream.once('data', (html) => {
  //   res.write(indexHTML.head)
  // })
  // // 每当新的块被渲染
  // renderStream.on('data', chunk => {
  //   console.log('chunk',chunk)
  //   // 将块写入响应
  //   res.write(chunk)
  // })
  // renderStream.on('end', () => {
  //   // 当vuex初始状态存在
  //   if (context.initialState) {
  //     // 将vuex初始状态以script的方式写入到页面中
  //     res.write(
  //       `<script>window.__INITIAL_STATE__=${serialize(context.initialState, {isJSON: true})}</script>`
  //     )
  //   }
  //
  //   // 将结尾的HTML写入响应
  //   res.end(indexHTML.tail)
  // })
  //
  // // 当渲染时发生错误
  // renderStream.on('error', err => {
  //   if (err && err.code === '404') {
  //     res.status(404).end('404 | Page Not Found')
  //     return
  //   }
  //   res.status(500).end('Internal Error 500')
  // })

  renderer.renderToString(context, (err, html) => {
    if (err) {
      return handleError(err)
    }
    let userInfo = context.state.userInfo ? context.state.userInfo : {code: 'INVALID'}

    if (userInfo.token && userInfo.userId) {
      res.cookie('token', userInfo.token || '', setConfigCookie)
      res.cookie('userId', userInfo.userId || '', setConfigCookie)
    }
    logInfo('PAGE_SEND', req.url, reqTime, req.cookies, context.state)
    res.send(html)
    // if (!isProd) {
    //   console.log(`whole request: ${Date.now() - s}ms`)
    // }
  })
}

let {post} = require('./src/api/create-api-server')
app.get('*', isProd ? render : (req, res) => {
  readyPromise.then(() => {
    render(req, res)
  })
})


function mysend (req, res, {token, userId}, results, reqTime) {
  // set cookie
  if (token && userId) {
    // if (results.data) delete results.data.token
    res.cookie('token', results.token, setConfigCookie)
    res.cookie('userId', results.userId, setConfigCookie)
  }
  res.status(200)
  res.send(results)
}

app.post('*', (req, res) => {
  logInfo('SEND_START', req.url, null, JSON.stringify(req.body), req.cookies)
  // console.log('body____', req.url.split('?')[0], req.body, req.cookies)
  let reqTime = new Date()
  let url = req.url.split('?')[0]
  let host = portconfig[req.body.hostKey || 'host']

  post(req.url, req.body, Object.assign({host: host}, req.cookies)).then((data) => {
    // user out
    /*if (url === '/newroad/service/logout') {
      res.clearCookie('token')
      res.clearCookie('tokenKey')
    }*/
    mysend(req, res, data, data, reqTime)
  }).catch(error => {
    res.send(error)
  })
})
// require('./src/api/config-api/config-api-server')(app)
let port = portconfig.port || 8080
app.listen(port, () => {
  console.log(`server started at localhost:${port}`)
})
// }
